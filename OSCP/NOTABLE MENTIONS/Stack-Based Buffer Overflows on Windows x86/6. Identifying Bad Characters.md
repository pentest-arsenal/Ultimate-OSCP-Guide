Before we start to utilize the fact that we can control the `EIP` and subvert the program's execution flow, we need to determine any characters we should avoid using in our payload.

As we are attacking an input parameter (an opened file in this case), the program is expected to process our input. So, depending on the processing each program executes on our input, certain characters may tell the program that it has reached the end of the input. This may happen even though it may not have reached the end of the input yet.

For example, a very common bad character is a null byte `0x00`, used in Assembly as a string terminator, which tells the processor the string has ended. So, if our payload included a null byte, the program may stop processing our shellcode, thinking it has reached the end of it. This will cause our payload not to execute correctly, and our attack would fail. More examples are `0x0a` and `0x0d`, which are the new line `\n` and carriage return `\r`, respectively. If we were exploiting a buffer overflow in a string input that is expected to be a single line (like a license key), these characters would probably end our input prematurely, which would also cause our payload to fail.

---

## Generating All Characters

To identify bad characters, we have to send all characters after filling the `EIP` address, which is after `4112` + `4` bytes. We then check whether any of the characters got removed by the program or if our input got truncated prematurely after a specific character.

To do this, we would need two files:

1. A `.wav` file with all characters to load into the program
2. A `.bin` file to compare with our input in memory

We can use `ERC` to generate the `.bin` file and generate a list of all characters to create our `.wav` file. To do so, we can use the `ERC --bytearray` command: ![ERC Byte Array](https://academy.hackthebox.com/storage/modules/89/win32bof_erc_bytearry.jpg)

This also creates two files on our Desktop:

- `ByteArray_1.txt`: Which contains the string of all characters we can use in our python exploit
- `ByteArray_1.bin`: Which we can use with `ERC` later to compare with our input in memory

---

## Updating our exploit

The next step would be to generate a `.wav` file with the characters string generated by `ERC`. We will once again write a new function `bad_chars()`, and use a similar code to the `eip_control()` function, but will use the characters under `C#` in `ByteArray_1.txt`. We will create a new list of bytes `all_chars = bytes([])`, and paste the characters between the brackets. We will then write to `chars.wav` the same `payload` from `eip_control()`, and add after it `all_chars`. The final function would look as follows:

Code: python

```python
def bad_chars():
    all_chars = bytes([
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        ...SNIP...
        0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
    ])
    
    offset = 4112
    buffer = b"A"*offset
    eip = b"B"*4
    payload = buffer + eip + all_chars
    
    with open('chars.wav', 'wb') as f:
        f.write(payload)

bad_chars()
```

Note how we added a `b` before `A` and `B` to turn them into bytes

We can now run our exploit with `F5` to generate the `chars.wav` file.

---

## Comparing our Input

Now we can restart our program in `x32dbg` and load `chars.wav` to it. Once we do, we can start comparing our input in memory and seeing whether any characters are missing. To do so, we can check the Stack pane on the bottom right of `x32dbg`, which should be aligned exactly at the beginning of our input: ![Byte Stack](https://academy.hackthebox.com/storage/modules/89/win32bof_bytes_stack.jpg)

We can now manually go through the stack line by line from right to left and ensure that all hex values are present, from `0x00` to `0xff`. As this may take a while, and we would entirely rely on our eyes, we may miss a character or two. So, we will once again utilize `ERC` to make the comparison for us. It will easily compare our input in memory to all characters.

We must first copy the address of `ESP` since this is where our input is located. We can do this by right-clicking on it and selecting `Copy value`, or clicking `[Ctrl + C]`: ![Byte ESP](https://academy.hackthebox.com/storage/modules/89/win32bof_bytes_esp.jpg)

Once we have the value of `ESP`, we can use `ERC --compare` and give it the `ESP` address and the location of the `.bin` file that contains all characters, as follows:

  Identifying Bad Characters

```cmd-session
ERC --compare 0014F974 C:\Users\htb-student\Desktop\ByteArray_1.bin
```

What this command will do is compare byte-by-byte both our input in `ESP` and all characters that we generated earlier in `ByteArray_1.bin`: ![Byte Compare 1](https://academy.hackthebox.com/storage/modules/89/win32bof_bytes_compare.jpg)

As we can see, this places each byte from both locations next to each other to quickly spot any issues. The output we seek is where all bytes from both locations are the same, with no differences whatsoever. However, we see that after the first character, `00`, all remaining bytes are different. `This indicates that 0x00 truncated the remaining input, and hence it should be considered a bad character.`

---

## Eliminating Bad Characters

Now that we have identified the first bad character, we should use `--bytearray` again to generate a list of all characters without the bad characters, which we can specify with `-bytes 0x00,0x0a,0x0d...etc.`. So, we will use the following command:

  Identifying Bad Characters

```cmd-session
ERC --bytearray -bytes 0x00
```

Now, let's use this command with `ERC` again to generate the new file and use it to update our exploit:

![ERC Byte Array 2](https://academy.hackthebox.com/storage/modules/89/win32bof_erc_bytearry_2.jpg)

As we can see, this time, it said `excluding: 00`, and the array table does not include `00` at the beginning. So, let's go to the generated output file `ByteArray_2.txt`, copy the new bytes under `C#`, and place them in our exploit, which should now look as follows:

Code: python

```python
def bad_chars():
    all_chars = bytes([
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
...SNIP...
```

Note: The `chars.wav` file may still be held by the debugger, and our python script may not be able to overwrite it. So, restart the program in `x32dbg` to release the file before running the exploit.

Once we have our new `chars.wav` file, we will once again load it in our program and use `--compare` with the new `ByteArray_2.bin` file to see whether both inputs match: ![Byte Compare 2](https://academy.hackthebox.com/storage/modules/89/win32bof_bytes_compare_2.jpg)

As we can see, this time, both lines match perfectly until `0xFF`, meaning that there are no more bad characters in our input. If we had identified another bad character, we would repeat the same process as we just did for `Eliminating Bad Characters` until both lines match perfectly.

So, now we know that we should avoid using `0x00` in the `EIP` address we want to execute or in our shellcode.

Tip: We would find that the characters `0x00`, `0x0a`, `0x0d` are often found to be bad characters in many programs and many vulnerable functions (as discussed earlier). So, to save time, we can consider these to be bad characters from the beginning, and look for other bad characters.

Note: The found bad characters in this section may not reflect the real bad characters for our program, as this was just a demonstration of how to identify bad characters. Try to repeat the process to find the real bad characters, if any.

**Credit:** This information was adapted from an excellent guide on [HTB Academy](https://academy.hackthebox.com/course/preview/stack-based-buffer-overflows-on-windows-x86). Be sure to check out the original post for more details.

