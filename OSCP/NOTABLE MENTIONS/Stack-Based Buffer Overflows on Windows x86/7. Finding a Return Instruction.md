As we have confirmed that we can control the address stored in `EIP` when the program executes the return instruction `ret`, we know that we can subvert the program execution and have it execute any instruction we want by writing the instruction's address to `EIP`, which would get executed after the return instruction `ret`.

But what instructions are at our disposal? And how would a single assembly instruction help us in gaining code execution? This is what we will discuss in this section.

---

## Subverting Program Flow

To successfully subvert the program's execution flow, we must write a working address at `EIP` that leads to an instruction that will benefit us. Currently, we have only written 4 `B`'s to `EIP`, which (obviously) is not a working address, and when the program attempts to go to this address, it will fail, which will lead the entire program to crash.

To find an address we can use, we must look at all of the instructions used or loaded by our program, pick one of them, and write its address at `EIP`. In modern systems with Address Space Layout Randomization (ASLR), if we choose an address, it will be useless, as it would change the next time our program runs since it gets randomized. In that case, we would have to follow a method of leaking the current set of addresses in real-time and use it in our exploit. However, we are not dealing with any of these types of protections in this module, so we can assume that the address we pick will not change, and we can safely use it in our program.

To know what instruction to use, we must first know what we want this address to do. While more advanced binary exploitation methods like `ROP` rely on utilizing and mapping various local instructions to perform the attack (like sending a reverse shell), we do not have to get this advanced yet, since we are dealing with a program with most memory protections disabled.

So, we will utilize a method known as `Jumping to Stack`.

---

## Jumping to Stack

As we already have input into the stack, which we are overflowing with data, we can potentially write instructions that will send us a reverse shell when executed (in the form of machine code/shellcode). Once we write our data to the stack, we can then direct the program execution flow to the stack, such that it starts executing our shellcode, at which point we would receive a reverse shell and gain control over the remote server.

To direct the execution flow to the stack, we must write an address to `EIP` to do so. This can be done in two ways:

1. Write the `ESP` address (top of the stack) to `EIP`, so it starts executing code found at the top stack
2. Using a `JMP ESP` instruction, which directs the execution flow to the stack

Before we continue, we must note that this method DOES NOT work with modern machines, as we have mentioned previously, and it is considered a legacy method of exploitation.  
![](https://academy.hackthebox.com/storage/modules/89/win32bof_stack_meme.png)

Modern systems and programs are compiled with the `NX` bit on the stack or the `DEP` memory protection in Windows, which prevents executing any code written on the stack. So, even if we would write the shellcode on the stack, it would not be executable, nor would we find a `JMP ESP` instruction we can use within the program.

However, as we mentioned at the beginning of the module, it is still very beneficial to start by learning such techniques, as they form more advanced techniques like `SEH` or `ROP`. Once we master this technique, our next step in binary exploitation would be to bypass protections and utilize more advanced methods to gain code execution without needing to write shellcode to the stack.

---

## Using ESP Address

Let's first try the most basic method of writing the address of the top of the stack `ESP`. Once we write an address to `EIP` and the program crashes on the return instruction `ret`, the debugger would stop at that point, and the `ESP` address at the point would match the beginning of our shellcode, similarly to how we saw our characters on the stack when looking for bad characters. We can take note of the `ESP` address at this point, which in this case is `0014F974`:

![Pattern EIP](https://academy.hackthebox.com/storage/modules/89/win32bof_pattern_eip.jpg)

Tip: We can also look at the stack on the bottom right pane to find the same details.

This method may work for this particular program, but it is not a very reliable method on Windows machines. First, the input we are attacking here is an audio file, so we see that all characters are allowed without bad characters. However, in many cases, we may be attacking a string input or a program argument, in which case `0x00` would be a bad character, and we would not use the address of `ESP` since it begins with `00`.

Another reason is that the address of `ESP` may not be the same on all machines. So, it may work throughout the debugging and exploit development process but may not be the same address when we fire the exploit at a real target, as it may have a different `ESP` address, at which point our exploit would fail.

Nevertheless, let's note this address and continue, and we'll test both methods in the next section.

---

## Using JMP ESP

The more reliable way of executing shellcode loaded on the stack is to find an instruction used by the program that directs the program's execution flow to the stack. We can use several such instructions, but we will be using the most basic one, `JMP ESP`, that jumps to the top of the stack and continues the execution.

#### Locating Modules

To find this instruction, we must look through executables and libraries loaded by our program. This includes:

1. The program's `.exe` file
2. The program's own `.dll` libraries
3. Any Windows `.dll` libraries used by the program

To find a list of all loaded files by the program, we can use `ERC --ModuleInfo`, as follows: ![Module Info](https://academy.hackthebox.com/storage/modules/89/win32bof_module_info.jpg)

We find many modules loaded by the program. However, we can skip any files with:

- `NXCompat`: As we are looking for a `JMP ESP` instruction, so the file should not have stack execution protection.
- `Rebase` or `ASLR`: Since these protections would cause the addresses to change between runs

As for `OS DLL`, if we are running on a newer Windows version like Windows 10, we can expect all OS DLL files to have all memory protections present, so we would not use any of them. If we were attacking an older Windows version like Windows XP, many of the loaded OS DLLs likely have no protections so that we can look for `JMP ESP` instructions in them as well.

If we only consider files with `False` set to all protections, we would get the following list:

  Finding a Return Instruction

```cmd-session
------------------------------------------------------------------------------------------------------------------------ 
 Base          | Entry point   | Size      | Rebase   | SafeSEH  | ASLR    | NXCompat | OS DLL  | Version, Name, and Path 
------------------------------------------------------------------------------------------------------------------------ 
0x400000        0xd88fc         0x11c000    False      False      False      False      False      C:\Program Files\CD to MP3 Freeware\cdextract.exe 
0x672c0000      0x1000          0x13000     False      False      False      False      False      1.0rc1;AKRip32;C:\Program Files\CD to MP3 Freeware\akrip32.dll 
0x10000000      0xa3e0          0xc000      False      False      False      False      False      C:\Program Files\CD to MP3 Freeware\ogg.dll
```

As we can see, all of the files belong to the program itself, which indicates that the program and all of its files were compiled without any memory protection, which means we may find `JMP ESP` instructions in them. `The best option is to use an instruction from the program itself, as we'll be sure that this address will exist regardless of the version of Windows running the program`.

#### Searching for JMP ESP

Now that we have a list of loaded files that may include the instruction we are looking for, we can search them for usable instructions. To access any of these files, we can go to the `Symbols` tab by clicking on it or hitting `alt+e`:

![Module Symbols](https://academy.hackthebox.com/storage/modules/89/win32bof_module_symbols.jpg)

We can start with `cdextract.exe` and double-click it to open view and search its instructions. To search for the `JMP ESP` instruction within the instructions of this file, we can click `ctrl+f`, which allows us to search for any instruction within the opened file `cdextract.exe`: ![Find Command](https://academy.hackthebox.com/storage/modules/89/win32bof_find_command.jpg)

We can enter `jmp esp`, and it should show us if this file contains any of the instructions we searched for: ![Find JMP ESP](https://academy.hackthebox.com/storage/modules/89/win32bof_find_jmp_esp.jpg)

As we can see, we found the following matches:

Code: shell

```cmd-shell
Address  Disassembly
00419D0B jmp esp
00463B91 jmp esp
00477A8B jmp esp
0047E58B jmp esp
004979F4 jmp esp
```

Note: We can also search for `CALL ESP`, which will also jump to the stack.

As is the case with the address when using the `ESP` address, `we must ensure that the instruction address does not contain any bad characters`. Otherwise, our payload would get truncated, and the attack would fail. However, in our case, we do not have any bad characters, so we can choose any of the above addresses.

We can double-click on any of the results to see the instruction in the main file disassembly and double-check that it is indeed a `JMP ESP` instruction.

We can also check the other loaded `.dll` files to see whether they contain any useful instructions, just in case any of the above did not work correctly. To do so, we can go back to the `Symbols` tab, double-clicking on the file we want to search, and then do the same process to search for the `JMP ESP` instruction.

If we had a large list of loaded modules, we could search through all of them by right-clicking on the main top right `CPU` pane and selecting `Search For> All Modules> Command`, then entering `jmp esp`. However, this may return a large list of results, some of which may not be usable. This is dependent on the protections present for its binary and if it is directly accessible by our program. Because of this, it's best to try to search within individual files first.

#### Searching for Patterns

Another example of a basic command to jump to the stack is `PUSH ESP` followed by `RET`. Since we are searching for two instructions, in this case, we should search using the machine code rather than the assembly instructions. We can use [Online Assemblers](https://defuse.ca/online-x86-assembler.htm), or the `msf-nasm_shell` tool found in `PwnBox` to convert any assembly instructions to machine code. Both of these take an assembly instruction and give us the corresponding machine code.

After using one of these, we would find that the machine code for `JMP ESP` is `FFE4`, and for `PUSH ESP; RET` is `54C3`. Now we can search using this pattern by clicking `ctrl+b` in the `CPU` pane and entering the pattern `54C3`:

![Find Pattern](https://academy.hackthebox.com/storage/modules/89/win32bof_find_pattern.jpg)

Once we do, we would find a few other addresses we can use as well: ![Find Pattern PUSH ESP](https://academy.hackthebox.com/storage/modules/89/win32bof_find_pattern_push_esp.jpg)

We can double-click any of them and confirm that it is indeed a `PUSH ESP` instruction followed by a `RET` instruction:

![PUSH ESP](https://academy.hackthebox.com/storage/modules/89/win32bof_pattern_push_esp.jpg)

---

## Summary

We have discussed many methods to find an instruction that would execute the shellcode we load on the stack:

1. We can use the `ESP` address
2. We can search loaded modules with disabled security for `JMP ESP` instructions
3. We can search for Assembly Instructions or search for machine code patterns
4. Any address we pick must not contain any bad characters

**Credit:** This information was adapted from an excellent guide on [HTB Academy](https://academy.hackthebox.com/course/preview/stack-based-buffer-overflows-on-windows-x86). Be sure to check out the original post for more details.

